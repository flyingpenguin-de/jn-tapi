#ifndef ONSIP_STATEMACHINE_H
#define ONSIP_STATEMACHINE_H

#include "onsipxmppevents.h"
#include "statemachine.h"
#include "onsipstatemachinebase.h"

// Class wrapper around the enum CallStates
// State enum for the OnSip call management state machine
class OnSipXmppStates
{
public:
	enum CallStates { Unknown=0, Offering=1, 
						PhysicalOutProceeding=2, 	// User is placing a call directly on the SIP phone
						Connected=3, Dropped=4, 
						PreMakeCall=5,		 // Make call needs to be done, no XMPP has been done yet
						MakeCallSet=6,       // A Make call IQ SET has been done, no response yet..
						MakeCallRequested=7, // The incoming REQUESTED dialog state for the Make Call request
						MakeCallRequestedAnswered=8,  // Caller answered their physical phone to continue the Make Call request
						MakeCallOutgoingCreated=9,	 // Outgoing call has been created to to complete the call
						PreDropCall=10				 // State before we attempt to drop the call
                     	};

	// Helper method to convert CallStates enum to a string (for debug purposes)
	static TCHAR *CallStateToString(CallStates state);
};

// Class wrapper around the enum CallType
class OnSipXmppCallType
{
public:
	enum CallType {  Unknown=0, MakeCall=1, 				// Call generated by XMPP
							IncomingCall=2, 			// Incoming call
							PhysicalCall=3 			// Outgoing call by person
							};

	// Helper method to convert CallType enum to a string (for debug purposes)
	static TCHAR *CallTypeToString(CallType calltype);
};

// State data maintained for each unique call,
// e.g. unique call-id, caller-id, etc.
class OnSipCallStateData
{
public:
	CheckThread _checkThread;
	long m_callId;							// Unique call-id, internal value, not related to OnSip callid
	string m_remoteId;
	string m_calledId;
	string m_sipCallId;						// The SIP callId
	OnSipXmppCallType::CallType m_callType;
	string m_fromTag;		// needed for DropCall
	string m_toTag;			// needed for DropCall

	OnSipCallStateData() 
	{  m_callId = 0;  m_callType = OnSipXmppCallType::Unknown; }

	const OnSipCallStateData& operator=(const OnSipCallStateData& callData)
	{
		_checkThread.CheckSameThread();	// Verify we are single threaded for this object
		if ( this == &callData )
			return *this;
		m_callType = callData.m_callType;
		m_callId = callData.m_callId; 
		m_remoteId = callData.m_remoteId; 
		m_calledId = callData.m_calledId; 
		m_sipCallId = callData.m_sipCallId;
		m_fromTag = callData.m_fromTag;
		m_toTag = callData.m_toTag;
		return *this;
	}

	tstring ToString() const;
};

// Utility class to provide helper methods for the OnSip state machine
// Provides all static methods
// TODO:  This is more of a general helper rather than just for CallState, move to different area??
class OnSipCallStateHelper
{
private:
	// Hide constructor, use static methods
	OnSipCallStateHelper() { }
public:

	static bool IsSameId(XmppEvent* pEvent1,XmppEvent* pEvent2);
	static bool IsSameContext(XmppEvent* pEvent1,XmppEvent* pEvent2);
	
	static XmppActiveCallEvent* getActiveCallEvent(XmppEvent* pEvent);
	static XmppRetractCallEvent* getRetractCallEvent(XmppEvent* pEvent);
	static XmppIqResultEvent* getXmppIqResultEvent(XmppEvent* pEvent);
	static XmppOnConnectEvent* getOnConnectEvent(XmppEvent* pEvent);
	static XmppOnDisconnectEvent* getOnDisconnectEvent(XmppEvent* pEvent);
	static XmppAuthEvent* getAuthEvent(XmppEvent* pEvent);
	static XmppPubSubSubscribedEvent* getPubSubSubscribedEvent(XmppEvent *pEvent);

	static void AssignCallStateData(OnSipCallStateData& callStateData,XmppActiveCallEvent* ace,long callId,bool bUpdateCallInfo=true);
};

//*************************************************************************
//*************************************************************************

// Call State Handler Base object.
// All Call State handlers inherit from this
class OnSipCallStateHandlerBase : public StateHandler<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>
{
public:
	OnSipCallStateHandlerBase( OnSipXmppStates::CallStates callState, XmppEvent* pEvent) : StateHandler<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>( callState , pEvent )
	{ }

	void assignNewState(OnSipXmppStates::CallStates callState,XmppEvent* pEvent)
	{
		Logger::log_debug(_T("OnSipCallStateHandlerBase::assignNewState callState=%d/%s"), callState, OnSipXmppStates::CallStateToString(callState) );
		StateHandler<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>::assignNewState(callState,pEvent);
	}

	void assignNewState(OnSipXmppStates::CallStates callState,XmppEvent* pEvent,OnSipCallStateData& stateData)
	{
		Logger::log_debug(_T("OnSipCallStateHandlerBase::assignNewState callState=%d/%s"), callState, OnSipXmppStates::CallStateToString(callState) );
		StateHandler<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>::assignNewState(callState,pEvent,stateData);
	}

	// General static helper method so can be used from PreExecute handlers.
	// Checks to see if the state has been in the specified state for the specified timeout in msecs.
	// If so, then the call will be put in the Dropped state and return true.
	static bool CheckStateTimeout( StateHandler<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>* pStateHandler, OnSipXmppStates::CallStates callState, DWORD timeout );

	// Checks to see if the state has been in the specified state for the specified timeout in msecs.
	// If so, then the call will be put in the Dropped state and return true.
	bool CheckStateTimeout( OnSipXmppStates::CallStates callState, DWORD timeout )
	{	return CheckStateTimeout( this, callState, timeout ); }
};

// Call State Handler Base object with "PreExecute" option that is
// derived from StateHandlerPreExecute.
// The PreExecute(OnSipXmpp* ) virtual is called on this instance
// before this StateHandler is added to the state machine.
class OnSipCallStateHandlerBasePreExecute : public StateHandlerPreExecute<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>
{
protected:
//	virtual bool PreExecute(OnSipXmpp *pOnSipXmpp) = 0;

public:
	OnSipCallStateHandlerBasePreExecute( OnSipXmppStates::CallStates callState, XmppEvent* pEvent) : StateHandlerPreExecute<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>( callState , pEvent )
	{ }

	void assignNewState(OnSipXmppStates::CallStates callState,XmppEvent* pEvent)
	{
		Logger::log_debug(_T("OnSipCallStateHandlerBasePreExecute::assignNewState callState=%d/%s"), callState, OnSipXmppStates::CallStateToString(callState) );
		StateHandler<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>::assignNewState(callState,pEvent);
	}

	void assignNewState(OnSipXmppStates::CallStates callState,XmppEvent* pEvent,OnSipCallStateData& stateData)
	{
		Logger::log_debug(_T("OnSipCallStateHandlerBasePreExecute::assignNewState callState=%d/%s"), callState, OnSipXmppStates::CallStateToString(callState) );
		StateHandler<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>::assignNewState(callState,pEvent,stateData);
	}

	// Checks to see if the state has been in the specified state for the specified timeout in msecs.
	// If so, then the call will be put in the Dropped state and return true.
	bool CheckStateTimeout( OnSipXmppStates::CallStates callState, DWORD timeout )
	{	return OnSipCallStateHandlerBase::CheckStateTimeout( this, callState, timeout ); }
};

//*************************************************************************
//*************************************************************************

// User outgoing call using physical phone device
class OnSipOutgoingCallStateHandler : public OnSipCallStateHandlerBase
{
private:
protected:
	virtual bool IsYourEvent(XmppEvent *pEvent);
	virtual bool IsStillExist();
public:
	OnSipOutgoingCallStateHandler(XmppEvent* pEvent,long callId);
};

//*************************************************************************
//*************************************************************************

// Incoming Call State Handler
class OnSipIncomingCallStateHandler : public OnSipCallStateHandlerBase
{
private:
protected:
	virtual bool IsYourEvent(XmppEvent *pEvent);
	virtual bool IsStillExist();

public:
	OnSipIncomingCallStateHandler(XmppEvent* pEvent,long callId);
};

//*************************************************************************
//*************************************************************************

// Generated Outgoing Call State Handler
// This is type of "PreExecute" since the number must be dialed
// before this StateHandler is added to the state machine.
class OnSipMakeCallStateHandler : public OnSipCallStateHandlerBasePreExecute
{
private:
protected:
	virtual bool IsYourEvent(XmppEvent *pEvent);
	virtual bool IsStillExist();
	int m_contextId;		// context for initial IQ request
	tstring m_in_id;		// Item ID of messages related to inbound call
	tstring m_out_id;		// Item ID of messages related to outbound call
	tstring m_toSipField;		// Exact TO field used in the XMPP request
	tstring m_fromSipField;	// Exact FROM field used in the XMPP request
	tstring m_in_sipCallId;	// SIP call ID associated with the incoming call
	tstring m_out_sipCallId;// SIP call ID associated with the outgoing call
public:
	// PreExecute method that will be called before
	// StateHandler is added to the state machine to
	// take care of the initial make call
	virtual bool PreExecute(OnSipStateMachineBase<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>* pStateMachine,OnSipXmpp *pOnSipXmpp);

	OnSipMakeCallStateHandler (const tstring& toDial,long callId);
};

//*************************************************************************
//*************************************************************************

// Handler to drop a call.
// This is type of "PreExecute", we drop the call in the PreExecute.
// The StateHandler is never added to the state machine, it is
// used just to drop the call.  Not added since we would then
// have 2 StateHandlers tracking the same call.
class OnSipDropCallStateHandler : public OnSipCallStateHandlerBasePreExecute
{
private:
protected:
	virtual bool IsYourEvent(XmppEvent *pEvent);
	virtual bool IsStillExist();

	long m_callId;			// call to be dropped
public:
	// PreExecute method that will be called before
	// StateHandler is added to the state machine to
	// take care of the drop call
	virtual bool PreExecute(OnSipStateMachineBase<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>* pStateMachine,OnSipXmpp *pOnSipXmpp);

	OnSipDropCallStateHandler (long callId);
};

//*************************************************************************
//*************************************************************************

class OnSipXmpp;

// Base class for IStateNotify that is associated with the CallStateMachine
// Inherit from this class to get state change notifies outside of the state handler, e.g. in state machine
class OnSipCallStateMachineNotifyBase : protected IStateNotify<OnSipXmppStates::CallStates,OnSipCallStateData>
{
	// Take over virtual that will be called from OnSipCallStateMachine for any changes
	// Pass on to a more meaningful name virtual
	virtual void StateChange(OnSipXmppStates::CallStates state,OnSipCallStateData stateData,StateChangeReason::eOnStateChangeReason reason)
	{	CallStateChange(state,stateData,reason);	}

protected:
	virtual void CallStateChange(OnSipXmppStates::CallStates state,OnSipCallStateData stateData,StateChangeReason::eOnStateChangeReason reason) = 0;
};

// OnSip State Machine that manages calls and their states
// using XmppEvent events
class OnSipCallStateMachine : public OnSipStateMachineBase<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>
{
	friend class OnSipXmpp;
private:

protected:
	virtual StateHandler<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData> *UnknownEvent(XmppEvent* pEvent);

	// Virtual notify that either the state has changed or the state data has changed
	virtual void OnStateChange(OnSipXmppStates::CallStates,OnSipCallStateData&,StateChangeReason::eOnStateChangeReason reason);

public:
	OnSipCallStateMachine(OnSipXmpp* pOnSipXmpp) : OnSipStateMachineBase(pOnSipXmpp)
	{ }

	// NOT thread-safe
	//
	// Find the specified call in the state machine.
	// Return its current calsltate and callstatedata.
	// Returns true if found
	bool FindCallState(long callId,OnSipXmppStates::CallStates* pCallState,OnSipCallStateData* pCallStateData);

	// NOT thread-safe
	//
	// Drop a phone call.  
	//  callId = unique ID for this call
	//  unique contextId for the IQ request, it will be in the IQ reply to match the request
	bool DropCall( long callId,int contextId );

	// THREAD-SAFE
	//
	// Make a phone call.  This will be done asynchrously.
	// The request will be inserted into the state machine for handling.
	// Returns the unique callid that refers to the unique ID for this call
	long MakeCallAsync( const tstring& phoneNumber );

	// THREAD-SAFE
	//
	// Drop a phone call.  This will be done asynchronously
	//  callId = unique ID for this call
	void DropCallAsync( long callId );
};


#endif
