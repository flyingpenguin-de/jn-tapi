#ifndef ONSIP_STATEMACHINE_H
#define ONSIP_STATEMACHINE_H

#include "onsipxmppevents.h"
#include "statemachine.h"
#include "onsipstatemachinebase.h"

// Class wrapper around the enum CallStates
// State enum for the OnSip call management state machine
class OnSipXmppStates
{
public:
	enum CallStates { Unknown=0, Offering=1, Proceeding=2, Connected=3, Dropped=4, 
						PreMakeCall=5,		 // Make call needs to be done, no XMPP has been done yet
						MakeCallSet=6,       // A Make call IQ SET has been done, no response yet..
						MakeCallRequested=7, // The incoming REQUESTED dialog state for the Make Call request
						MakeCallRequestedAnswered=8,  // Caller answered their physical phone to continue the Make Call request
						MakeCallOutgoingCreated=9	 // Outgoing call has been created to to complete the call
                     	};

	// Helper method to convert CallStates enum to a string (for debug purposes)
	static TCHAR *CallStateToString(CallStates state);
};

// Class wrapper around the enum CallType
class OnSipXmppCallType
{
public:
	enum CallType {  Unknown=0, MakeCall=1, 				// Call generated by XMPP
							IncomingCall=2, 			// Incoming call
							PhysicalCall=3 			// Outgoing call by person
							};

	// Helper method to convert CallType enum to a string (for debug purposes)
	static TCHAR *CallTypeToString(CallType calltype);
};

// State data maintained for each unique call,
// e.g. unique call-id, caller-id, etc.
class OnSipCallStateData
{
public:
	CheckThread _checkThread;
	long m_callId;							// Unique call-id, internal value, not related to OnSip callid
	string m_remoteId;
	string m_calledId;
	string m_sipCallId;						// The SIP callId
	OnSipXmppCallType::CallType m_callType;

	OnSipCallStateData() 
	{  m_callId = 0;  m_callType = OnSipXmppCallType::Unknown; }

	const OnSipCallStateData& operator=(const OnSipCallStateData& callData)
	{
		_checkThread.CheckSameThread();	// Verify we are single threaded for this object
		if ( this == &callData )
			return *this;
		m_callType = callData.m_callType;
		m_callId = callData.m_callId; 
		m_remoteId = callData.m_remoteId; 
		m_calledId = callData.m_calledId; 
		m_sipCallId = callData.m_sipCallId;
		return *this;
	}

	tstring ToString() const;
};

// Utility class to provide helper methods for the OnSip state machine
// Provides all static methods
// TODO:  This is more of a general helper rather than just for CallState, move to different area??
class OnSipCallStateHelper
{
private:
	// Hide constructor, use static methods
	OnSipCallStateHelper() { }
public:

	static bool IsSameId(XmppEvent* pEvent1,XmppEvent* pEvent2);
	static bool IsSameContext(XmppEvent* pEvent1,XmppEvent* pEvent2);
	
	static XmppActiveCallEvent* getActiveCallEvent(XmppEvent* pEvent);
	static XmppRetractCallEvent* getRetractCallEvent(XmppEvent* pEvent);
	static XmppIqResultEvent* getXmppIqResultEvent(XmppEvent* pEvent);
	static XmppOnConnectEvent* getOnConnectEvent(XmppEvent* pEvent);
	static XmppOnDisconnectEvent* getOnDisconnectEvent(XmppEvent* pEvent);
	static XmppAuthEvent* getAuthEvent(XmppEvent* pEvent);
	static XmppPubSubSubscribedEvent* getPubSubSubscribedEvent(XmppEvent *pEvent);

	static void AssignCallStateData(OnSipCallStateData& callStateData,XmppActiveCallEvent* ace,long callId,bool bUpdateCallInfo=true);
};

//*************************************************************************
//*************************************************************************

// Call State Handler Base object.
// All Call State handlers inherit from this
class OnSipCallStateHandlerBase : public StateHandler<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>
{
public:
	OnSipCallStateHandlerBase( OnSipXmppStates::CallStates callState, XmppEvent* pEvent) : StateHandler<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>( callState , pEvent )
	{ }

	void assignNewState(OnSipXmppStates::CallStates callState,XmppEvent* pEvent)
	{
		Logger::log_debug(_T("OnSipCallStateHandlerBase::assignNewState callState=%d/%s"), callState, OnSipXmppStates::CallStateToString(callState) );
		StateHandler<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>::assignNewState(callState,pEvent);
	}

	void assignNewState(OnSipXmppStates::CallStates callState,XmppEvent* pEvent,OnSipCallStateData& stateData)
	{
		Logger::log_debug(_T("OnSipCallStateHandlerBase::assignNewState callState=%d/%s"), callState, OnSipXmppStates::CallStateToString(callState) );
		StateHandler<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>::assignNewState(callState,pEvent,stateData);
	}
};

// Call State Handler Base object with "PreExecute" option that is
// derived from StateHandlerPreExecute.
// The PreExecute(OnSipXmpp* ) virtual is called on this instance
// before this StateHandler is added to the state machine.
class OnSipCallStateHandlerBasePreExecute : public StateHandlerPreExecute<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>
{
protected:
//	virtual bool PreExecute(OnSipXmpp *pOnSipXmpp) = 0;

public:
	OnSipCallStateHandlerBasePreExecute( OnSipXmppStates::CallStates callState, XmppEvent* pEvent) : StateHandlerPreExecute<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>( callState , pEvent )
	{ }

	void assignNewState(OnSipXmppStates::CallStates callState,XmppEvent* pEvent)
	{
		Logger::log_debug(_T("OnSipCallStateHandlerBasePreExecute::assignNewState callState=%d/%s"), callState, OnSipXmppStates::CallStateToString(callState) );
		StateHandler<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>::assignNewState(callState,pEvent);
	}

	void assignNewState(OnSipXmppStates::CallStates callState,XmppEvent* pEvent,OnSipCallStateData& stateData)
	{
		Logger::log_debug(_T("OnSipCallStateHandlerBasePreExecute::assignNewState callState=%d/%s"), callState, OnSipXmppStates::CallStateToString(callState) );
		StateHandler<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>::assignNewState(callState,pEvent,stateData);
	}
};

//*************************************************************************
//*************************************************************************

// User outgoing call using physical phone device
class OnSipOutgoingCallStateHandler : public OnSipCallStateHandlerBase
{
private:
protected:
	virtual bool IsYourEvent(XmppEvent *pEvent);
	virtual bool IsStillExist();
public:
	OnSipOutgoingCallStateHandler(XmppEvent* pEvent,long callId);
};

//*************************************************************************
//*************************************************************************

// Incoming Call State Handler
class OnSipIncomingCallStateHandler : public OnSipCallStateHandlerBase
{
private:
protected:
	virtual bool IsYourEvent(XmppEvent *pEvent);
	virtual bool IsStillExist();

public:
	OnSipIncomingCallStateHandler(XmppEvent* pEvent,long callId);
};

//*************************************************************************
//*************************************************************************

// Generated Outgoing Call State Handler
// This is type of "PreExecute" since the number must be dialed
// before this StateHandler is added to the state machine.
class OnSipMakeCallStateHandler : public OnSipCallStateHandlerBasePreExecute
{
private:
protected:
	virtual bool IsYourEvent(XmppEvent *pEvent);
	virtual bool IsStillExist();
	int m_contextId;		// context for initial IQ request
	tstring m_in_id;		// Item ID of messages related to inbound call
	tstring m_out_id;		// Item ID of messages related to outbound call
	tstring m_toSipField;		// Exact TO field used in the XMPP request
	tstring m_fromSipField;	// Exact FROM field used in the XMPP request
	tstring m_in_sipCallId;	// SIP call ID associated with the incoming call
	tstring m_out_sipCallId;// SIP call ID associated with the outgoing call
public:
	// PreExecute method that will be called before
	// StateHandler is added to the state machine to
	// take care of the initial make call
	virtual bool PreExecute(OnSipXmpp *pOnSipXmpp);

	OnSipMakeCallStateHandler (const tstring& toDial,long callId);
};

//*************************************************************************
//*************************************************************************

class OnSipXmpp;

// Base class for IStateNotify that is associated with the CallStateMachine
// Inherit from this class to get state change notifies outside of the state handler, e.g. in state machine
class OnSipCallStateMachineNotifyBase : protected IStateNotify<OnSipXmppStates::CallStates,OnSipCallStateData>
{
	// Take over virtual that will be called from OnSipCallStateMachine for any changes
	// Pass on to a more meaningful name virtual
	virtual void StateChange(OnSipXmppStates::CallStates state,OnSipCallStateData stateData,StateChangeReason::eOnStateChangeReason reason)
	{	CallStateChange(state,stateData,reason);	}

protected:
	virtual void CallStateChange(OnSipXmppStates::CallStates state,OnSipCallStateData stateData,StateChangeReason::eOnStateChangeReason reason) = 0;
};

// OnSip State Machine that manages calls and their states
// using XmppEvent events
class OnSipCallStateMachine : public OnSipStateMachineBase<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData>
{
	friend class OnSipXmpp;
private:

protected:
	virtual StateHandler<OnSipXmppStates::CallStates,XmppEvent,OnSipCallStateData> *UnknownEvent(XmppEvent* pEvent);

	// Virtual notify that either the state has changed or the state data has changed
	virtual void OnStateChange(OnSipXmppStates::CallStates,OnSipCallStateData&,StateChangeReason::eOnStateChangeReason reason);

public:
	OnSipCallStateMachine(OnSipXmpp* pOnSipXmpp) : OnSipStateMachineBase(pOnSipXmpp)
	{ }

	// THREAD-SAFE
	//
	// Make a phone call.  This will be done asynchrously.
	// The request will be inserted into the state machine for handling.
	// Returns the unique callid that refers to the unique ID for this call
	long MakeCall( const tstring& phoneNumber );
};


#endif
