/***************************************************************************
//
// MAKECALL.CPP
//
// TAPI Service provider for TSP++ version 3.0
// lineMakeCall and lineDial management
//
// Copyright (C) 2009 Junction Networks
// All rights reserved
//
// Generated by the TSPWizard © 2009 JulMar Technology, Inc.
// 
/***************************************************************************/

/*----------------------------------------------------------------------------
	INCLUDE FILES
-----------------------------------------------------------------------------*/
#include "stdafx.h"
#include "OnSip.h"

/*****************************************************************************
** Procedure:  COnSipLine::OnMakeCall
**
** Arguments: 'pReq' - Request object representing this MAKECALL event 
**            'lpBuff' - The event block pointer
**
** Returns:    void
**
** Description:  This function manages the TSPI_lineMakeCall processing
**               for this service provider. 
**
*****************************************************************************/
bool COnSipLine::OnMakeCall(RTMakeCall* pRequest, LPCVOID lpBuff)
{
	// Cast the input opaque pointer back to an event block
	const COnSipEvent* pEvent = static_cast<const COnSipEvent*>(lpBuff);
	CTSPICallAppearance* pCall = pRequest->GetCallInfo();
	DIALINFO* pAddress = (pRequest->GetCount() > 0) ? pRequest->GetDialableNumber(0) : NULL;

	// See if this is a call event
	const COnSip_CallEvent* pCallEvent = (pEvent == NULL) ? NULL : COnSipEvent::getCallEvent(pEvent);
	// Get the CallId from the call event
	DWORD callEventCallId = (pCallEvent == NULL) ? 0 : pCallEvent->CallId();

	Logger::log_debug( _T("COnSipLine::OnMakeCall lpBuff=%p callEvent=%p pCall.CallId=%d evt.Callid=%ld"), lpBuff, pCallEvent, pCall->GetCallID(), callEventCallId );
	
	// If we are in the initial state (i.e. this request has not been processed
	// before by any other thread). Then move the packet to the waiting state so 
	// other threads will not interfere with other events or timers.  This is 
	// guaranteed to be thread-safe and atomic.
	if (pRequest->EnterState(STATE_INITIAL, STATE_IGNORE))
	{
		Logger::log_debug( _T("COnSipLine::OnMakeCall STATE_INITIAL pAddr=%p number=%s isPartial=%d"), 
			pAddress, (pAddress == NULL) ? NULL : pAddress->strNumber.c_str(), (pAddress == NULL) ? NULL : pAddress->fIsPartialAddress );

		// If we have no dialing information (i.e. NULL specified in lineMakeCall)
		// or the number given is incomplete (i.e. it is terminated by a semicolon
		// as per the TAPI specification) then mark the call as a "fake" call until 
		// we collect enough digits to actually place the call.
		if (pAddress == NULL || pAddress->strNumber.empty() )
		{
			Logger::log_error( _T("COnSipLine::OnMakeCall STATE_INITIAL invalid number") );
			CompleteRequest(pRequest,LINEERR_OPERATIONFAILED);
			return true;
		}

		// Otherwise we have a number to dial - send it to the PBX
		// Transition to the WAITING state
		pRequest->SetState(STATE_WAITING);
			
		// Send the dial string to the Device
		long callid = GetDeviceInfo()->DRV_MakeCall(this, pAddress->strNumber, pRequest->GetCountryCode());
		Logger::log_debug( _T("COnSipLine::OnMakeCall STATE_INITIAL DRV_MakeCall callid=%ld"), callid );
		// If error
		if ( callid < 0 )
		{
			Logger::log_error( _T("COnSipLine::OnMakeCall STATE_INITIAL DRV_MakeCall failed") );
			CompleteRequest(pRequest,LINEERR_OPERATIONFAILED);
			return true;
		}

		// If success, keep track of the callid
		pCall->SetCallID( (DWORD) callid );
		return true;
	}

	// If we are in the waiting stage (2) then see if we received an event from the
	// switch (vs. an interval timer) and if that event was an ACK/NAK in response
	// to the command we issued.
	else if (pRequest->GetState() == STATE_WAITING && pCallEvent != NULL && callEventCallId == pCall->GetCallID() )
	{
		// Get the TAPI callstate for this event
		DWORD dwCallState = pCallEvent->GetTapiCallState();

		Logger::log_debug( _T("COnSipLine::OnMakeCall STATE_WAITING callId=%d tapiCallState=%ld"), callEventCallId, dwCallState );

		// If IDLE callstate, then must be some type of error
		if ( dwCallState == LINECALLSTATE_IDLE )
		{
			Logger::log_error( _T("COnSipLine::OnMakeCall STATE_WAITING IDLE callId=%d %s"), callEventCallId, pCallEvent->ToString().c_str() );
			CompleteRequest(pRequest, LINEERR_OPERATIONFAILED);
		}
		else
		{
			Logger::log_debug( _T("COnSipLine::OnMakeCall STATE_WAITING callId=%d callstate=%d"), callEventCallId, dwCallState );

			// Complete this request so that TAPI will forward on callstate information
			// to applications. Make sure to tell TSP++ to not delete the request yet
			// by using the last parameter
			CompleteRequest(pRequest, 0, true, false);		// true=bTellTapi,   false=bRemove

			// Because the request is "complete" in TAPI's eyes, we can adjust the
			// call state and change call information (assigned trunk, caller-id, etc.)
			// Change the call state to dialtone.
			pCall->SetCallState(dwCallState, LINEDIALTONEMODE_NORMAL, LINEMEDIAMODE_INTERACTIVEVOICE);

			// Finally, destroy the request from our list now that we have
			// setup the call appearance. This releases the address information.
			CompleteRequest(pRequest, 0);
		}
		return true;
	}

	// Check to see if our request has exceeded the limit for processing.  If 
	// so, tell TAPI that the request failed and delete the request.
	if (pRequest->GetState() == STATE_WAITING &&
		(pRequest->GetStateTime()+REQUEST_TIMEOUT) < GetTickCount())
	{
		Logger::log_error( _T("COnSipLine::OnMakeCall STATE_WAITING timeout") );
		CompleteRequest(pRequest, LINEERR_OPERATIONFAILED);
	}

	// Let the request fall through to the unsolicited handler
	return false;

}// COnSipLine::OnMakeCall

/*****************************************************************************
** Procedure:  COnSipLine::OnDial
**
** Arguments: 'pReq' - Request object representing this DIAL event 
**            'lpBuff' - Our CEventBlock* pointer
**
** Returns:    void
**
** Description:  This function manages the TSPI_lineDial processing
**               for this service provider.
**
*****************************************************************************/
bool COnSipLine::OnDial(RTDial* pRequest, LPCVOID lpBuff)
{
	// Cast the input opaque pointer back to an event block
	const COnSipEvent* pEvent = static_cast<const COnSipEvent*>(lpBuff);
	CTSPICallAppearance* pCall = pRequest->GetCallInfo();
	DIALINFO* pAddress = (pRequest->GetCount() > 0) ? pRequest->GetDialableNumber(0) : NULL;
	
	// If we are in the initial state (i.e. this request has not been processed
	// before by any other thread). Then move the packet to the waiting state so 
	// other threads will not interfere with other events or timers.  This is 
	// guaranteed to be thread-safe and atomic.
	if (pRequest->EnterState(STATE_INITIAL, STATE_IGNORE))
	{
		// TODO: Examine the dialing string and convert TAPI special indicator
		// characters to the appropriate information to send to the device. The
		// supported characters are:
		//
		// ! - Indicates that a hookflash (one-half second onhook, followed by one-half 
		// second offhook before continuing) is to be inserted in the dial string.
		//
		// t/T - Indicates that tone (DTMF) dialing is to be used for the digits 
		// following it
		//
		// p/P - Indicates that pulse dialing is to be used for the digits following it.
		// , - Indicates that dialing is to be paused. The duration of a pause is 
		// specified by GetLineDevCaps()->DefaultDialParams.dwDialPause. 
		// Multiple commas can be used to provide longer pauses

		// TODO: Send a command to place a call on this line

		// Transition the waiting state - waiting for a hardware response
		pRequest->SetState(STATE_WAITING);
	}

	// If we are in the waiting stage (2) then see if we received an event from the
	// switch (vs. an interval timer) and if that event was an ACK/NAK in response
	// to the command we issued.
	else if (pRequest->GetState() == STATE_WAITING && lpBuff != NULL)
	{
		// TODO: Check the return code from the PBX and fail the request or
		// complete it with a zero return code

		bool fError = false;
		if (fError == false)
		{
			// Complete this request so that TAPI will forward on callstate information
			// to applications. Make sure to tell TSP++ to not delete the request yet
			// by using the last parameter
			CompleteRequest(pRequest, 0, true, false);

			// Because the request is "complete" in TAPI's eyes, we can adjust the
			// call state and change call information (assigned trunk, caller-id, etc.)
			// Change the call state to dialtone.
			pCall->SetCallState(LINECALLSTATE_DIALTONE, 
						LINEDIALTONEMODE_NORMAL, LINEMEDIAMODE_INTERACTIVEVOICE);

			// TODO: Associate the call-id from the hardware with the call object so we
			// can find it later.
			// pCall->SetCallID(dwCallID);

			// TODO: Add any additional information to the call which was received from
			// the hardware. Another option is to do this in the unsolicited handler
			// found in UNSOLICITED.CPP - this is especially helpful if the event can
			// be received independent of a call being placed by the TSP (i.e. external
			// stimulus
			//
			// pCall->SetTrunk (...) etc.


			// Transition to the dialing stage and the the proceeding (waiting for ringback) state
			pCall->SetCallState(LINECALLSTATE_DIALING);
			pCall->SetCallState(LINECALLSTATE_PROCEEDING);

			// Finally, destroy the request from our list now that we have
			// setup the call appearance. This releases the address information.
			CompleteRequest(pRequest, 0);
		}
		return true;
	}

	// Check to see if our request has exceeded the limit for processing.  If 
	// so, tell TAPI that the request failed and delete the request.
	if (pRequest->GetState() == STATE_WAITING && 
		(pRequest->GetStateTime()+REQUEST_TIMEOUT) < GetTickCount())
		CompleteRequest(pRequest, LINEERR_OPERATIONFAILED);

	// Let the request fall through to the unsolicited handler
	return false;

}// COnSipLine::OnDial
